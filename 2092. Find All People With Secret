class Solution {
public:
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {
        set<int> known={0,firstPerson},seentime;
        vector<vector<pair<int,int>>> sortedmeeting;
        sort(meetings.begin(),meetings.end(),[](const vector<int> & a,const vector<int> & b){
            return a[2]<b[2];
        });
        for(const vector<int>& meeting:meetings){
            if(seentime.find(meeting[2])==seentime.end()){
                seentime.insert(meeting[2]);
                sortedmeeting.push_back({});
            }
            sortedmeeting.back().push_back({meeting[0],meeting[1]});
        }
        for(const vector<pair<int,int>> & meetgroup:sortedmeeting){
            set<int> pknew;
            map<int,vector<int>> graph;
            for(const pair<int,int> &p:meetgroup){
                graph[p.first].push_back(p.second);
                graph[p.second].push_back(p.first);
                if(known.find(p.first)!=known.end()) pknew.insert(p.second);
                if(known.find(p.second)!=known.end()) pknew.insert(p.first);
            }
            queue<int> q;
            for(int person:pknew) q.push(person);
            while(!q.empty()){
                int current=q.front();
                q.pop();
                known.insert(current);
                for(int secret: graph[current]){
                    if(known.find(secret)==known.end()){
                        known.insert(secret);
                        q.push(secret);
                    }

                }
            }
            
        }
        vector<int> ans(known.begin(),known.end());
        return ans;

    }
};



